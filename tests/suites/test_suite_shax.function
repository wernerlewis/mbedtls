/* BEGIN_HEADER */
#include "mbedtls/sha1.h"
#include "mbedtls/sha256.h"
#include "mbedtls/sha512.h"
/* END_HEADER */

/* BEGIN_CASE depends_on:MBEDTLS_SHA1_C */
void mbedtls_sha1( data_t * src_str, data_t * hash )
{
    unsigned char output[41];

    memset(output, 0x00, 41);


    TEST_ASSERT( mbedtls_sha1( src_str->x, src_str->len, output ) == 0 );

    TEST_ASSERT( mbedtls_test_hexcmp( output, hash->x, 20, hash->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA1_C */
void mbedtls_sha1_copy_context( data_t * src_str, data_t * hash )
{
    unsigned char output1[41], output2[41];
    mbedtls_sha1_context ctx, ctx_copy;
    size_t halfway = src_str->len / 2;

    mbedtls_sha1_init( &ctx );

    // Start SHA1 and update with first half of src
    TEST_ASSERT( mbedtls_sha1_starts( &ctx ) == 0 );

    TEST_ASSERT( mbedtls_sha1_update( &ctx, src_str->x, halfway ) == 0 );

    // Copy context and complete second half
    ctx_copy = ctx;
    TEST_ASSERT( mbedtls_sha1_update( &ctx, src_str->x + halfway,
                                      src_str->len - halfway ) == 0 );
    TEST_ASSERT( mbedtls_sha1_finish( &ctx, output1 ) == 0 );

    // Clear original context and complete from copy
    memset( &ctx, 0, sizeof( ctx ) );
    TEST_ASSERT( mbedtls_sha1_update( &ctx_copy, src_str->x + halfway,
                                      src_str->len - halfway ) == 0 );
    TEST_ASSERT( mbedtls_sha1_finish( &ctx_copy, output2 ) == 0 );

    // Check hash matches
    TEST_ASSERT( mbedtls_test_hexcmp( output1, output2, 20, 20 ) == 0 );
    TEST_ASSERT( mbedtls_test_hexcmp( output1, hash->x, 20, hash->len ) == 0 );
    mbedtls_sha1_free( &ctx_copy );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C:NOT_DEFINED */
void sha256_invalid_param( )
{
    mbedtls_sha256_context ctx;
    unsigned char buf[64] = { 0 };
    size_t const buflen = sizeof( buf );
    int valid_type = 0;
    int invalid_type = 42;

    TEST_EQUAL( MBEDTLS_ERR_SHA256_BAD_INPUT_DATA,
                            mbedtls_sha256_starts( &ctx, invalid_type ) );

    TEST_EQUAL( MBEDTLS_ERR_SHA256_BAD_INPUT_DATA,
                            mbedtls_sha256( buf, buflen,
                                                buf, invalid_type ) );

exit:
    return;
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA224_C */
void sha224( data_t * src_str, data_t * hash )
{
    unsigned char output[57];

    memset(output, 0x00, 57);


    TEST_ASSERT( mbedtls_sha256( src_str->x, src_str->len, output, 1 ) == 0 );

    TEST_ASSERT( mbedtls_test_hexcmp( output, hash->x, 28, hash->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C */
void mbedtls_sha256( data_t * src_str, data_t * hash )
{
    unsigned char output[65];

    memset(output, 0x00, 65);


    TEST_ASSERT( mbedtls_sha256( src_str->x, src_str->len, output, 0 ) == 0 );

    TEST_ASSERT( mbedtls_test_hexcmp( output, hash->x, 32, hash->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C */
void mbedtls_sha256_copy_context( data_t * src_str, data_t * hash )
{
    unsigned char output1[65], output2[65];
    mbedtls_sha256_context ctx, ctx_copy;
    size_t halfway = src_str->len / 2;

    mbedtls_sha256_init( &ctx );

    // Start SHA256 and update with first half of src
    TEST_ASSERT( mbedtls_sha256_starts( &ctx, 0 ) == 0 );

    TEST_ASSERT( mbedtls_sha256_update( &ctx, src_str->x, halfway ) == 0 );

    // Copy context and complete second half
    ctx_copy = ctx;
    TEST_ASSERT( mbedtls_sha256_update( &ctx, src_str->x + halfway,
                                      src_str->len - halfway ) == 0 );
    TEST_ASSERT( mbedtls_sha256_finish( &ctx, output1 ) == 0 );

    // Clear original context and complete from copy
    memset( &ctx, 0, sizeof( ctx ) );
    TEST_ASSERT( mbedtls_sha256_update( &ctx_copy, src_str->x + halfway,
                                      src_str->len - halfway ) == 0 );
    TEST_ASSERT( mbedtls_sha256_finish( &ctx_copy, output2 ) == 0 );

    // Check hash matches
    TEST_ASSERT( mbedtls_test_hexcmp( output1, output2, 32, 32 ) == 0 );
    TEST_ASSERT( mbedtls_test_hexcmp( output1, hash->x, 32, hash->len ) == 0 );
    mbedtls_sha256_free( &ctx_copy );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C:NOT_DEFINED */
void sha512_invalid_param( )
{
    mbedtls_sha512_context ctx;
    unsigned char buf[64] = { 0 };
    size_t const buflen = sizeof( buf );
    int valid_type = 0;
    int invalid_type = 42;

    TEST_EQUAL( MBEDTLS_ERR_SHA512_BAD_INPUT_DATA,
                            mbedtls_sha512_starts( &ctx, invalid_type ) );

    TEST_EQUAL( MBEDTLS_ERR_SHA512_BAD_INPUT_DATA,
                            mbedtls_sha512( buf, buflen,
                                                buf, invalid_type ) );

exit:
    return;
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA384_C */
void sha384( data_t * src_str, data_t * hash )
{
    unsigned char output[97];

    memset(output, 0x00, 97);


    TEST_ASSERT( mbedtls_sha512( src_str->x, src_str->len, output, 1 ) == 0 );

    TEST_ASSERT( mbedtls_test_hexcmp( output, hash->x, 48, hash->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C */
void mbedtls_sha512( data_t * src_str, data_t * hash )
{
    unsigned char output[129];

    memset(output, 0x00, 129);


    TEST_ASSERT( mbedtls_sha512( src_str->x, src_str->len, output, 0 ) == 0 );

    TEST_ASSERT( mbedtls_test_hexcmp( output, hash->x, 64, hash->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C */
void mbedtls_sha512_copy_context( data_t * src_str, data_t * hash )
{
    unsigned char output1[129], output2[129];
    mbedtls_sha512_context ctx, ctx_copy;
    size_t halfway = src_str->len / 2;

    mbedtls_sha512_init( &ctx );

    // Start SHA512 and update with first half of src
    TEST_ASSERT( mbedtls_sha512_starts( &ctx, 0 ) == 0 );

    TEST_ASSERT( mbedtls_sha512_update( &ctx, src_str->x, halfway ) == 0 );

    // Copy context and complete second half
    ctx_copy = ctx;
    TEST_ASSERT( mbedtls_sha512_update( &ctx, src_str->x + halfway,
                                      src_str->len - halfway ) == 0 );
    TEST_ASSERT( mbedtls_sha512_finish( &ctx, output1 ) == 0 );

    // Clear original context and complete from copy
    memset( &ctx, 0, sizeof( ctx ) );
    TEST_ASSERT( mbedtls_sha512_update( &ctx_copy, src_str->x + halfway,
                                      src_str->len - halfway ) == 0 );
    TEST_ASSERT( mbedtls_sha512_finish( &ctx_copy, output2 ) == 0 );

    // Check hash matches
    TEST_ASSERT( mbedtls_test_hexcmp( output1, output2, 64, 64 ) == 0 );
    TEST_ASSERT( mbedtls_test_hexcmp( output1, hash->x, 64, hash->len) == 0 );
    mbedtls_sha512_free( &ctx_copy );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA1_C:MBEDTLS_SELF_TEST */
void sha1_selftest(  )
{
    TEST_ASSERT( mbedtls_sha1_self_test( 1 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C:MBEDTLS_SELF_TEST */
void sha256_selftest(  )
{
    TEST_ASSERT( mbedtls_sha256_self_test( 1 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C:MBEDTLS_SELF_TEST */
void sha512_selftest(  )
{
    TEST_ASSERT( mbedtls_sha512_self_test( 1 ) == 0 );
}
/* END_CASE */
